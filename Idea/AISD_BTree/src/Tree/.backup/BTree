package Tree;

public class BTree {
    final static int t = 2;
    Node root = null;

    public BTree() {
    }

    void insertToNode(int key, Node node) {
        node.keys[node.countKey] = key;
        node.countKey++;
        sort(node);
    }

    void sort(Node node) {
        int buf;
        for (int i = 0; i < 2 * t - 1; i++) {
            for (int j = i + 1; j <= 2 * t - 1; j++) {
                if ((node.keys[i] != 0) && (node.keys[j] != 0)) {
                    if ((node.keys[i]) > (node.keys[j])) {
                        buf = node.keys[i];
                        node.keys[i] = node.keys[j];
                        node.keys[j] = buf;
                    } else break;
                }
            }
        }
    }

    void split(Node node) {
        if (node.countKey < (2 * t - 1)) return;

        Node child1 = new Node();
        int j;
        for (j = 0; j <= t - 2; j++) child1.keys[j] = node.keys[j];
        for (j = t - 1; j < 2 * t - 1; j++) child1.keys[j] = 0;
        child1.countKey = t - 1;
        if (node.countChild != 0) {
            for (int i = 0; i <= t - 1; i++) {
                child1.child[i] = node.child[i];
                child1.child[i].parent = child1;
            }
            for (int i = t; i <= (2 * t); i++) child1.child[i] = null;
            child1.leaf = false;
            child1.countChild = t - 1;
        } else {
            child1.leaf = true;
            child1.countChild = 0;
            for (int i = 0; i <= 2 * t; i++) child1.child[i] = null;
        }

        Node child2 = new Node();
        for (j = 0; j <= t - 1; j++) child2.keys[j] = node.keys[j + t];
        for (j = t; j <= 2 * t - 1; j++) child2.keys[j] = 0;
        child2.countKey = t; //количество ключей в узле
        if (node.countChild != 0) {
            for (int i = 0; i <= t; i++) {
                child2.child[i] = node.child[i + t];
                child2.child[i].parent = child2;
            }
            for (int i = t + 1; i <= 2 * t; i++) child2.child[i] = null;
            child2.leaf = false;
            child2.countChild = t; //количество сыновей
        } else {
            child2.leaf = true;
            child2.countChild = 0;
            for (int i = 0; i <= (2 * t); i++) child2.child[i] = null;
        }

        if (node.parent == null) {
            node.keys[0] = node.keys[t - 1];
            for (int i = 1; i <= 2 * t - 1; i++) node.keys[i] = 0;
            node.child[0] = child1;
            node.child[1] = child2;
            for (int i = 2; i <= 2 * t; i++) node.child[i] = null;
            node.parent = null;
            node.leaf = false;
            node.countKey = 1;
            node.countChild = 2;
            child1.parent = node;
            child2.parent = node;
        } else {
            insertToNode(node.keys[t - 1], node.parent);
            for (int i = 0; i <= 2 * t; i++) {
                if (node.parent.child[i] == node) node.parent.child[i] = null;
            }
            for (int i = 0; i <= 2 * t; i++) {
                if (node.parent.child[i] == null) {
                    for (j = 2 * t; j > i + 1; j--) node.parent.child[j] = node.parent.child[j - 1];
                    node.parent.child[i + 1] = child2;
                    node.parent.child[i] = child1;
                    break;
                }
            }
            child1.parent = node.parent;
            child2.parent = node.parent;
            node.parent.leaf = false;
            node = null;
        }
    }

    void deleteNode(Node node) {
        if (node.parent != null) {
            node.parent.countChild--;
            if (node.parent.child[0] == node) {
                node.parent.child[0] = node.parent.child[1];
            } else if (node.parent.child[1] == node) {
                node.parent.child[1] = null;
            }
        }
    }

    boolean searchKey(int key, Node node) {
        if (node != null) {
            if (!node.leaf) {
                int i;
                for (i = 0; i <= 2 * t - 1; i++) {
                    if (node.keys[i] != 0) {
                        if (key == node.keys[i]) return true;
                        if (key < node.keys[i]) {
                            return searchKey(key, node.child[i]);
                        }
                    } else break;
                }
                return searchKey(key, node.child[i]);
            } else {
                for (int i = 0; i <= 2 * t - 1; i++) if (key == node.keys[i]) return true;
                return false;
            }
        } else return false;
    }

    void remove(int key, Node node) {
        Node ptr = node;
        int position = 0; //номер ключа
        int i;
        for (i = 0; i <= node.countKey - 1; i++) {
            if (key == node.keys[i]) {
                position = i;
                break;
            }
        }
        int positionSon = 0; //номер сына по отношению к родителю
        if (ptr.parent != null) {
            for (i = 0; i <= ptr.parent.countKey; i++) {
                if (ptr.child[i] == ptr) {
                    positionSon = i;
                    break;
                }
            }
        }
        //находим наименьший ключ правого поддерева
        ptr = ptr.child[position + 1];
        int newkey = ptr.keys[0];
        while (!ptr.leaf) ptr = ptr.child[0];
        //если ключей в найденном листе не больше 1 - ищем наибольший ключ в левом поддереве
        //иначе - просто заменяем key на новый ключ, удаляем новый ключ из листа
        if (ptr.countKey > (t - 1)) {
            newkey = ptr.keys[0];
            removeFromNode(newkey, ptr);
            node.keys[position] = newkey;
        } else {
            ptr = node;
            //ищем наибольший ключ в левом поддереве
            ptr = ptr.child[position];
            newkey = ptr.keys[ptr.countKey - 1];
            while (!ptr.leaf) ptr = ptr.child[ptr.countKey];
            newkey = ptr.keys[ptr.countKey - 1];
            node.keys[position] = newkey;
            if (ptr.countKey > (t - 1)) removeFromNode(newkey, ptr);
            else {
                //если ключей не больше, чем t-1 - перестраиваем
                removeLeaf(newkey, ptr);
            }
        }
    }

    void removeFromNode(int key, Node node) {
        for (int i = 0; i < node.countKey; i++) {
            if (node.keys[i] == key) {
                for (int j = i; j < node.countKey; j++) {
                    node.keys[j] = node.keys[j + 1];
                    node.child[j] = node.child[j + 1];
                }
                node.keys[node.countKey - 1] = 0;
                node.child[node.countKey - 1] = node.child[node.countKey];
                node.child[node.countKey] = null;
                break;
            }
        }
        node.countKey--;
    }

    void removeLeaf(int key, Node node) {
        if ((node == root) && (node.countKey == 1)) {
            removeFromNode(key, node);
            root.child[0] = null;
            root = null;
            return;
        }
        if (node == root) {
            removeFromNode(key, node);
            return;
        }
        if (node.countKey > (t - 1)) {
            removeFromNode(key, node);
            return;
        }
        Node ptr = node;
        int k1;
        int k2;
        int position;
        int positionSon = 0;
        int i;
        for (i = 0; i <= node.countKey - 1; i++) {
            if (key == node.keys[i]) {
                position = i; //позиция ключа в узле
                break;
            }
        }
        Node parent = ptr.parent;
        for (int j = 0; j <= parent.countKey; j++) {
            if (parent.child[j] == ptr) {
                positionSon = j; //позиция узла по отношению к родителю
                break;
            }
        }
        //если ptr-первый ребенок (самый левый)
        if (positionSon == 0) {
            if (parent.child[positionSon + 1].countKey > (t - 1)) { //если у правого брата больше, чем t-1 ключей
                k1 = parent.child[positionSon + 1].keys[0]; //k1 - минимальный ключ правого брата
                k2 = parent.keys[positionSon]; //k2 - ключ родителя, больше, чем удаляемый, и меньше, чем k1
                insertToNode(k2, ptr);
                removeFromNode(key, ptr);
                parent.keys[positionSon] = k1; //меняем местами k1 и k2
                removeFromNode(k1, parent.child[positionSon + 1]); //удаляем k1 из правого брата
            } else { //если у правого <u>единственного</u> брата не больше t-1 ключей
                removeFromNode(key, ptr);
                if (ptr.countKey <= (t - 2)) reBuildTree(ptr);
            }
        } else {
            //если ptr-последний ребенок (самый правый)
            if (positionSon == parent.countKey) {
                //если у левого брата больше, чем t-1 ключей
                if (parent.child[positionSon - 1].countKey > (t - 1)) {
                    Node temp = parent.child[positionSon - 1];
                    k1 = temp.keys[temp.countKey - 1]; //k1 - максимальный ключ левого брата
                    k2 = parent.keys[positionSon - 1]; //k2 - ключ родителя, меньше, чем удаляемый и больше, чем k1
                    insertToNode(k2, ptr);
                    removeFromNode(key, ptr);
                    parent.keys[positionSon - 1] = k1;
                    removeFromNode(k1, temp);
                } else { //если у <u>единственного</u> левого брата не больше t-1 ключей
                    removeFromNode(key, ptr);
                    if (ptr.countKey <= (t - 2)) reBuildTree(ptr);
                }
            } else { //если ptr имеет братьев справа и слева
                //если у правого брата больше, чем t-1 ключей
                if (parent.child[positionSon + 1].countKey > (t - 1)) {
                    k1 = parent.child[positionSon + 1].keys[0]; //k1 - минимальный ключ правого брата
                    k2 = parent.keys[positionSon]; //k2 - ключ родителя, больше, чем удаляемый и меньше, чем k1
                    insertToNode(k2, ptr);
                    removeFromNode(key, ptr);
                    parent.keys[positionSon] = k1; //меняем местами k1 и k2
                    removeFromNode(k1, parent.child[positionSon + 1]); //удаляем k1 из правого брата
                } else {
                    //если у левого брата больше, чем t-1 ключей
                    if (parent.child[positionSon - 1].countKey > (t - 1)) {
                        Node temp = parent.child[positionSon - 1];
                        k1 = temp.keys[temp.countKey - 1]; //k1 - максимальный ключ левого брата
                        k2 = parent.keys[positionSon - 1]; //k2 - ключ родителя, меньше, чем удаляемый и больше, чем k1
                        insertToNode(k2, ptr);
                        removeFromNode(key, ptr);
                        parent.keys[positionSon - 1] = k1;
                        removeFromNode(k1, temp);
                    } else { //если у обоих братьев не больше t-1 ключей
                        removeFromNode(key, ptr);
                        if (ptr.countKey <= (t - 2)) reBuildTree(ptr);
                    }
                }
            }
        }
    }

    void leftConn(Node node, Node node2) {
        if (node == null) return;
        for (int i = 0; i <= (node2.countKey - 1); i++) {
            node.keys[node.countKey] = node2.keys[i];
            node.child[node.countKey] = node2.child[i];
            node.countKey++;
        }
        node.child[node.countKey] = node2.child[node2.countKey];
        for (int j = 0; j <= node.countKey; j++) {
            if (node.child[j] == null) break;
            node.child[j].parent = node;
        }
    }

    void rightConn(Node node, Node node2) {
        if (node == null) return;
        for (int i = 0; i <= (node2.countKey - 1); i++) {
            node.keys[node.countKey] = node2.keys[i];
            node.child[node.countKey + 1] = node2.child[i + 1];
            node.countKey++;
        }
        for (int j = 0; j <= node.countKey; j++) {
            if (node.child[j] == null) break;
            node.child[j].parent = node;
        }
    }

    void reBuildTree(Node node) {
        if ((node == root) && (node.countKey == 0)) {
            if (root.child[0] != null) {
                root.child[0].parent = null;
                root = root.child[0];
            } else {
                root = null;
            }
            return;
        }
        Node ptr = node;
        int positionSon = 0;
        Node parent = ptr.parent;
        for (int j = 0; j <= parent.countKey; j++) {
            if (parent.child[j] == ptr) {
                positionSon = j; //позиция узла по отношению к родителю
                break;
            }
        }
        //если ptr-первый ребенок (самый левый)
        if (positionSon == 0) {
            insertToNode(parent.keys[positionSon], ptr);
            leftConn(ptr, parent.child[positionSon + 1]);
            parent.child[positionSon + 1] = ptr;
            parent.child[positionSon] = null;
            removeFromNode(parent.keys[positionSon], parent);
            if (ptr.countKey == 2 * t) {
                while (ptr.countKey == 2 * t) {
                    if (ptr == root) {
                        split(ptr);
                        break;
                    } else {
                        split(ptr);
                        ptr = ptr.parent;
                    }
                }
            } else if (parent.countKey <= (t - 2)) reBuildTree(parent);
        } else {
            //если ptr-последний ребенок (самый правый)
            if (positionSon == parent.countKey) {
                insertToNode(parent.keys[positionSon - 1], parent.child[positionSon - 1]);
                leftConn(parent.child[positionSon - 1], ptr);
                parent.child[positionSon] = parent.child[positionSon - 1];
                parent.child[positionSon - 1] = null;
                removeFromNode(parent.keys[positionSon - 1], parent);
                Node temp = parent.child[positionSon];
                if (ptr.countKey == 2 * t) {
                    while (temp.countKey == 2 * t) {
                        if (temp == root) {
                            split(temp);
                            break;
                        } else {
                            split(temp);
                            temp = temp.parent;
                        }
                    }
                } else if (parent.countKey <= (t - 2)) reBuildTree(parent);
            } else { //если ptr имеет братьев справа и слева
                insertToNode(parent.keys[positionSon], ptr);
                leftConn(ptr, parent.child[positionSon + 1]);
                parent.child[positionSon + 1] = ptr;
                parent.child[positionSon] = null;
                removeFromNode(parent.keys[positionSon], parent);
                if (ptr.countKey == 2 * t) {
                    while (ptr.countKey == 2 * t) {
                        if (ptr == root) {
                            split(ptr);
                            break;
                        } else {
                            split(ptr);
                            ptr = ptr.parent;
                        }
                    }
                } else if (parent.countKey <= (t - 2)) reBuildTree(parent);
            }
        }
    }

    public void insert(int key) {
        if (root == null) {
            Node newRoot = new Node();
            newRoot.keys[0] = key;
            for (int j = 1; j <= (2 * t - 1); j++) newRoot.keys[j] = 0;
            for (int i = 0; i <= (2 * t); i++) newRoot.child[i] = null;
            newRoot.countKey = 1;
            newRoot.countChild = 0;
            newRoot.leaf = true;
            newRoot.parent = null;
            root = newRoot;
        } else {
            Node ptr = root;
            while (!ptr.leaf) {
                for (int i = 0; i <= 2 * t - 1; i++) {
                    if (ptr.keys[i] != 0) {
                        if (key < ptr.keys[i]) {
                            ptr = ptr.child[i];
                            break;
                        }
                        if ((ptr.keys[i + 1] == 0) && (key > ptr.keys[i])) {
                            ptr = ptr.child[i + 1];
                            break;
                        }
                    } else break;

                }
            }
            insertToNode(key, ptr);
            while (ptr.countKey == 2 * t) {
                if (ptr == root) {
                    split(ptr);
                    break;
                } else {
                    split(ptr);
                    ptr = ptr.parent;
                }
            }
        }
    }

    public boolean search(int key) {
        return searchKey(key, root);
    }

    public void remove(int key) {
        Node ptr = this.root;
        int position;
        int positionSon;
        int i;
        if (!searchKey(key, ptr)) {
            return;
        } else {
            //ищем узел, в котором находится ключ для удаления
            for (i = 0; i <= ptr.countKey - 1; i++) {
                if (ptr.keys[i] != 0) {
                    if (key == ptr.keys[i]) {
                        position = i;
                        break;
                    } else {
                        if ((key < ptr.keys[i])) {
                            ptr = ptr.child[i];
                            positionSon = i;
                            i = -1;
                        } else {
                            if (i == (ptr.countKey - 1)) {
                                ptr = ptr.child[i + 1];
                                positionSon = i + 1;
                                i = -1;
                            }
                        }
                    }
                } else break;
            }
        }
        if (ptr.leaf) {
            if (ptr.countKey > (t - 1)) removeFromNode(key, ptr);
            else removeLeaf(key, ptr);
        } else remove(key, ptr);
    }

}
